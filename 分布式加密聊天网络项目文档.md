# åˆ†å¸ƒå¼åŠ å¯†èŠå¤©ç½‘ç»œé¡¹ç›®æ–‡æ¡£

## 1. é¡¹ç›®æ¦‚è¿°

### 1.1 é¡¹ç›®ç›®æ ‡
æ„å»ºä¸€ä¸ª**åˆ†å¸ƒå¼ã€ç«¯åˆ°ç«¯åŠ å¯†ã€å®Œå…¨åŒ¿å**çš„èŠå¤©ç½‘ç»œï¼Œå…·å¤‡ä»¥ä¸‹ç‰¹ç‚¹ï¼š
- ğŸ”’ **å®Œå…¨åŒ¿å**ï¼šç±»ä¼¼æš—ç½‘ï¼Œæ— éœ€èº«ä»½éªŒè¯
- ğŸŒ **åˆ†å¸ƒå¼æ¶æ„**ï¼šæ¯ä¸ªç”¨æˆ·éƒ½æ˜¯èŠ‚ç‚¹ï¼Œæ— ä¸­å¿ƒæœåŠ¡å™¨
- ğŸ” **ç«¯åˆ°ç«¯åŠ å¯†**ï¼šä½¿ç”¨Signal Protocolç¡®ä¿é€šä¿¡å®‰å…¨
- ğŸ›¡ï¸ **é˜²åƒåœ¾ä¿¡æ¯**ï¼šåŸºäºå·¥ä½œé‡è¯æ˜(PoW)æœºåˆ¶
- ğŸ’» **è·¨å¹³å°**ï¼šæ”¯æŒæ¡Œé¢åº”ç”¨å’Œæµè§ˆå™¨åº”ç”¨

### 1.2 æŠ€æœ¯å¯è¡Œæ€§åˆ†æ

âœ… **å®Œå…¨å¯è¡Œ**

- **åˆ†å¸ƒå¼ç½‘ç»œæŠ€æœ¯**ï¼šlibp2på·²æˆç†Ÿï¼Œæ”¯æŒå¤šç§ä¼ è¾“åè®®
- **ç«¯åˆ°ç«¯åŠ å¯†**ï¼šSignal Protocolå·²è¢«å¹¿æ³›éªŒè¯å’Œä½¿ç”¨
- **é˜²åƒåœ¾ä¿¡æ¯**ï¼šå·¥ä½œé‡è¯æ˜æœºåˆ¶å·²æœ‰æˆç†Ÿæ–¹æ¡ˆ
- **è·¨å¹³å°æ”¯æŒ**ï¼šç°ä»£WebæŠ€æœ¯å¯å®ç°æ¡Œé¢å’Œæµè§ˆå™¨åŒç«¯éƒ¨ç½²

## 2. æŠ€æœ¯æ¶æ„è®¾è®¡

### 2.1 æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   åˆ†å¸ƒå¼èŠå¤©ç½‘ç»œ                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  å‰ç«¯å±‚ (Vue.js)                                        â”‚
â”‚  â”œâ”€ èŠå¤©ç•Œé¢                                            â”‚
â”‚  â”œâ”€ èŠ‚ç‚¹ç®¡ç†                                            â”‚
â”‚  â”œâ”€ åŠ å¯†çŠ¶æ€æ˜¾ç¤º                                        â”‚
â”‚  â””â”€ ç½‘ç»œçŠ¶æ€ç›‘æ§                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  åº”ç”¨å±‚ (Node.js)                                       â”‚
â”‚  â”œâ”€ æ¶ˆæ¯å¤„ç†                                            â”‚
â”‚  â”œâ”€ åŠ å¯†/è§£å¯†                                           â”‚
â”‚  â”œâ”€ é˜²åƒåœ¾ä¿¡æ¯                                          â”‚
â”‚  â””â”€ ç”¨æˆ·ç®¡ç†                                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  P2Pç½‘ç»œå±‚ (libp2p)                                     â”‚
â”‚  â”œâ”€ èŠ‚ç‚¹å‘ç°                                            â”‚
â”‚  â”œâ”€ æ¶ˆæ¯è·¯ç”±                                            â”‚
â”‚  â”œâ”€ è¿æ¥ç®¡ç†                                            â”‚
â”‚  â””â”€ ç½‘ç»œåè®®                                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ä¼ è¾“å±‚                                                 â”‚
â”‚  â”œâ”€ WebRTC (æµè§ˆå™¨-æµè§ˆå™¨)                              â”‚
â”‚  â”œâ”€ WebSocket (æµè§ˆå™¨-èŠ‚ç‚¹)                             â”‚
â”‚  â”œâ”€ TCP/UDP (èŠ‚ç‚¹-èŠ‚ç‚¹)                                 â”‚
â”‚  â””â”€ WebTransport (æ–°æ ‡å‡†æ”¯æŒ)                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  åŠ å¯†å±‚ (Signal Protocol)                               â”‚
â”‚  â”œâ”€ X3DH å¯†é’¥åå•†                                       â”‚
â”‚  â”œâ”€ Double Ratchet å¯†é’¥ç®¡ç†                             â”‚
â”‚  â”œâ”€ å‰å‘å®‰å…¨æ€§                                          â”‚
â”‚  â””â”€ åå‘å®‰å…¨æ€§                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 æ ¸å¿ƒæŠ€æœ¯ç»„ä»¶

#### 2.2.1 P2Pç½‘ç»œå±‚ - libp2p
```javascript
// libp2pé…ç½®ç¤ºä¾‹
const libp2p = await createLibp2p({
  addresses: {
    listen: ['/webrtc', '/ip4/0.0.0.0/tcp/0/ws']
  },
  transports: [
    webRTC(),
    webSockets({ filter: filters.all }),
    webTransport(),
    circuitRelayTransport({
      discoverRelays: 3,
    })
  ],
  connectionEncryption: [noise()],
  streamMuxers: [yamux()],
  services: {
    identify: identify(),
    pubsub: gossipsub(),
    dht: kad(),
    relay: circuitRelayServer()
  }
});
```

#### 2.2.2 åŠ å¯†åè®® - Signal Protocol
```javascript
// Signal Protocolå®ç°
class SignalProtocolManager {
  constructor() {
    this.identityKey = generateIdentityKey();
    this.sessions = new Map();
  }

  async initializeSession(remoteIdentity) {
    // X3DHå¯†é’¥äº¤æ¢
    const x3dhResult = await this.performX3DH(remoteIdentity);
    
    // åˆå§‹åŒ–Double Ratchet
    const ratchet = new DoubleRatchet(x3dhResult.sharedKey);
    this.sessions.set(remoteIdentity, ratchet);
    
    return ratchet;
  }

  async encryptMessage(recipientId, plaintext) {
    const session = this.sessions.get(recipientId);
    return await session.encrypt(plaintext);
  }

  async decryptMessage(senderId, ciphertext) {
    const session = this.sessions.get(senderId);
    return await session.decrypt(ciphertext);
  }
}
```

## 3. å‰ç«¯è®¾è®¡ (Vue.js)

### 3.1 æŠ€æœ¯æ ˆ
- **æ¡†æ¶**: Vue 3 + Composition API
- **çŠ¶æ€ç®¡ç†**: Pinia
- **UIç»„ä»¶**: Element Plus / Naive UI
- **æ„å»ºå·¥å…·**: Vite
- **TypeScript**: å®Œæ•´ç±»å‹æ”¯æŒ

### 3.2 æ ¸å¿ƒç»„ä»¶è®¾è®¡

#### 3.2.1 èŠå¤©ç•Œé¢ç»„ä»¶
```vue
<template>
  <div class="chat-container">
    <div class="chat-header">
      <div class="peer-info">
        <span class="peer-id">{{ currentPeer.id }}</span>
        <span class="encryption-status" :class="{ secure: isEncrypted }">
          {{ isEncrypted ? 'ğŸ”’ å·²åŠ å¯†' : 'ğŸ”“ æœªåŠ å¯†' }}
        </span>
      </div>
      <div class="network-status">
        <span class="node-count">èŠ‚ç‚¹æ•°: {{ connectedNodes }}</span>
        <span class="connection-quality">è¿æ¥è´¨é‡: {{ connectionQuality }}</span>
      </div>
    </div>
    
    <div class="message-list" ref="messageList">
      <div 
        v-for="message in messages" 
        :key="message.id"
        class="message-item"
        :class="{ 'own-message': message.isOwn }"
      >
        <div class="message-header">
          <span class="sender-id">{{ message.senderId }}</span>
          <span class="timestamp">{{ formatTime(message.timestamp) }}</span>
        </div>
        <div class="message-content">{{ message.content }}</div>
      </div>
    </div>
    
    <div class="message-input">
      <input 
        v-model="newMessage" 
        @keyup.enter="sendMessage"
        placeholder="è¾“å…¥æ¶ˆæ¯..."
        class="input-field"
      />
      <button @click="sendMessage" class="send-button">å‘é€</button>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, nextTick } from 'vue';
import { useP2PStore } from '@/stores/p2p';
import { useEncryptionStore } from '@/stores/encryption';

const p2pStore = useP2PStore();
const encryptionStore = useEncryptionStore();

const messages = ref([]);
const newMessage = ref('');
const messageList = ref();

const sendMessage = async () => {
  if (!newMessage.value.trim()) return;
  
  const message = {
    id: generateMessageId(),
    content: newMessage.value,
    timestamp: Date.now(),
    isOwn: true
  };
  
  // åŠ å¯†å¹¶å‘é€æ¶ˆæ¯
  await p2pStore.sendMessage(message);
  messages.value.push(message);
  newMessage.value = '';
  
  // æ»šåŠ¨åˆ°åº•éƒ¨
  await nextTick();
  messageList.value.scrollTop = messageList.value.scrollHeight;
};

onMounted(() => {
  // ç›‘å¬æ¥æ”¶çš„æ¶ˆæ¯
  p2pStore.onMessage((message) => {
    messages.value.push(message);
  });
});
</script>
```

#### 3.2.2 èŠ‚ç‚¹ç®¡ç†ç»„ä»¶
```vue
<template>
  <div class="node-manager">
    <div class="node-stats">
      <div class="stat-item">
        <h3>{{ connectedPeers }}</h3>
        <p>è¿æ¥èŠ‚ç‚¹</p>
      </div>
      <div class="stat-item">
        <h3>{{ totalMessages }}</h3>
        <p>æ€»æ¶ˆæ¯æ•°</p>
      </div>
      <div class="stat-item">
        <h3>{{ networkLatency }}ms</h3>
        <p>ç½‘ç»œå»¶è¿Ÿ</p>
      </div>
    </div>
    
    <div class="peer-list">
      <h3>å·²è¿æ¥èŠ‚ç‚¹</h3>
      <div v-for="peer in peers" :key="peer.id" class="peer-item">
        <div class="peer-info">
          <span class="peer-id">{{ peer.id.substr(0, 8) }}...</span>
          <span class="connection-time">{{ formatDuration(peer.connectedAt) }}</span>
        </div>
        <div class="peer-actions">
          <button @click="startChat(peer)" class="action-btn">èŠå¤©</button>
          <button @click="disconnectPeer(peer)" class="action-btn danger">æ–­å¼€</button>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { computed } from 'vue';
import { useP2PStore } from '@/stores/p2p';

const p2pStore = useP2PStore();

const connectedPeers = computed(() => p2pStore.peers.length);
const peers = computed(() => p2pStore.peers);
const totalMessages = computed(() => p2pStore.messageCount);
const networkLatency = computed(() => p2pStore.averageLatency);

const startChat = (peer) => {
  p2pStore.startChatWith(peer.id);
};

const disconnectPeer = (peer) => {
  p2pStore.disconnectPeer(peer.id);
};
</script>
```

### 3.3 çŠ¶æ€ç®¡ç† (Pinia)

```javascript
// stores/p2p.js
import { defineStore } from 'pinia';
import { P2PNetwork } from '@/services/P2PNetwork';
import { SignalProtocolManager } from '@/services/SignalProtocolManager';

export const useP2PStore = defineStore('p2p', {
  state: () => ({
    node: null,
    peers: [],
    messages: [],
    isConnected: false,
    signalManager: null,
    currentChatPeer: null
  }),

  actions: {
    async initialize() {
      this.node = new P2PNetwork();
      this.signalManager = new SignalProtocolManager();
      
      await this.node.start();
      this.setupEventListeners();
      this.isConnected = true;
    },

    setupEventListeners() {
      this.node.on('peer:connect', (peer) => {
        this.peers.push(peer);
        this.setupEncryptionSession(peer);
      });

      this.node.on('peer:disconnect', (peerId) => {
        this.peers = this.peers.filter(p => p.id !== peerId);
      });

      this.node.on('message', async (message) => {
        const decrypted = await this.signalManager.decryptMessage(
          message.senderId, 
          message.content
        );
        
        this.messages.push({
          ...message,
          content: decrypted,
          isOwn: false
        });
      });
    },

    async sendMessage(message) {
      if (!this.currentChatPeer) return;
      
      const encrypted = await this.signalManager.encryptMessage(
        this.currentChatPeer.id,
        message.content
      );
      
      await this.node.sendMessage(this.currentChatPeer.id, {
        ...message,
        content: encrypted
      });
    },

    async setupEncryptionSession(peer) {
      await this.signalManager.initializeSession(peer.id);
    }
  }
});
```

## 4. åç«¯è®¾è®¡ (Node.js)

### 4.1 æŠ€æœ¯æ ˆ
- **è¿è¡Œæ—¶**: Node.js 18+
- **P2Påº“**: libp2p
- **åŠ å¯†åº“**: @signalapp/libsignal-client
- **æ•°æ®åº“**: å†…å­˜å­˜å‚¨ (å¯é€‰SQLite)
- **æ„å»ºå·¥å…·**: TypeScript + esbuild

### 4.2 æ ¸å¿ƒæœåŠ¡è®¾è®¡

#### 4.2.1 P2Pç½‘ç»œæœåŠ¡
```javascript
// services/P2PNetwork.js
import { createLibp2p } from 'libp2p';
import { webRTC } from '@libp2p/webrtc';
import { webSockets } from '@libp2p/websockets';
import { noise } from '@chainsafe/libp2p-noise';
import { yamux } from '@chainsafe/libp2p-yamux';
import { gossipsub } from '@chainsafe/libp2p-gossipsub';
import { identify } from '@libp2p/identify';
import { SpamFilter } from './SpamFilter.js';

export class P2PNetwork extends EventEmitter {
  constructor() {
    super();
    this.node = null;
    this.peers = new Map();
    this.spamFilter = new SpamFilter();
  }

  async start() {
    this.node = await createLibp2p({
      addresses: {
        listen: [
          '/webrtc',
          '/ip4/0.0.0.0/tcp/0/ws',
          '/ip4/0.0.0.0/udp/0/quic'
        ]
      },
      transports: [
        webRTC(),
        webSockets({ filter: filters.all }),
        webTransport(),
        circuitRelayTransport({
          discoverRelays: 3,
        })
      ],
      connectionEncryption: [noise()],
      streamMuxers: [yamux()],
      services: {
        identify: identify(),
        pubsub: gossipsub(),
        dht: kad(),
        relay: circuitRelayServer()
      }
    });

    await this.node.start();
    this.setupEventHandlers();
    this.startPeerDiscovery();
    
    console.log('P2PèŠ‚ç‚¹å·²å¯åŠ¨:', this.node.peerId.toString());
  }

  setupEventHandlers() {
    this.node.addEventListener('peer:connect', (evt) => {
      const peer = evt.detail;
      this.peers.set(peer.toString(), {
        id: peer.toString(),
        connectedAt: Date.now(),
        messageCount: 0
      });
      
      this.emit('peer:connect', peer);
    });

    this.node.addEventListener('peer:disconnect', (evt) => {
      const peerId = evt.detail.toString();
      this.peers.delete(peerId);
      this.emit('peer:disconnect', peerId);
    });

    // ç›‘å¬æ¶ˆæ¯
    this.node.services.pubsub.addEventListener('message', (evt) => {
      this.handleMessage(evt.detail);
    });
  }

  async handleMessage(message) {
    const { topic, data, from } = message;
    
    if (topic === '/chat/1.0.0') {
      const messageData = JSON.parse(new TextDecoder().decode(data));
      
      // é˜²åƒåœ¾ä¿¡æ¯æ£€æŸ¥
      if (await this.spamFilter.isSpam(messageData, from)) {
        console.log('åƒåœ¾ä¿¡æ¯å·²è¿‡æ»¤:', messageData.id);
        return;
      }
      
      this.emit('message', {
        ...messageData,
        senderId: from.toString()
      });
    }
  }

  async sendMessage(recipientId, message) {
    const messageData = {
      id: generateMessageId(),
      content: message.content,
      timestamp: Date.now(),
      recipient: recipientId
    };

    await this.node.services.pubsub.publish(
      '/chat/1.0.0',
      new TextEncoder().encode(JSON.stringify(messageData))
    );
  }

  async startPeerDiscovery() {
    // ä½¿ç”¨GossipSubè¿›è¡ŒèŠ‚ç‚¹å‘ç°
    await this.node.services.pubsub.subscribe('/discovery/1.0.0');
    
    // å®šæœŸå¹¿æ’­è‡ªå·±çš„å­˜åœ¨
    setInterval(() => {
      this.announceSelf();
    }, 30000);
  }

  async announceSelf() {
    const announcement = {
      peerId: this.node.peerId.toString(),
      timestamp: Date.now(),
      capabilities: ['chat', 'file-transfer']
    };

    await this.node.services.pubsub.publish(
      '/discovery/1.0.0',
      new TextEncoder().encode(JSON.stringify(announcement))
    );
  }
}
```

#### 4.2.2 Signal Protocolé›†æˆ
```javascript
// services/SignalProtocolManager.js
import * as SignalProtocol from '@signalapp/libsignal-client';

export class SignalProtocolManager {
  constructor() {
    this.store = new InMemorySignalStore();
    this.identityKey = null;
    this.sessions = new Map();
  }

  async initialize() {
    // ç”Ÿæˆèº«ä»½å¯†é’¥
    this.identityKey = SignalProtocol.PrivateKey.generate();
    
    // ä¿å­˜åˆ°å­˜å‚¨
    await this.store.saveIdentity(
      this.getOwnAddress(),
      this.identityKey.publicKey()
    );
  }

  async initializeSession(remoteAddress) {
    try {
      // æ‰§è¡ŒX3DHå¯†é’¥äº¤æ¢
      const bundle = await this.fetchPreKeyBundle(remoteAddress);
      const sessionBuilder = new SignalProtocol.SessionBuilder(
        this.store,
        remoteAddress
      );
      
      await sessionBuilder.processPreKeyBundle(bundle);
      
      // åˆ›å»ºä¼šè¯
      const sessionCipher = new SignalProtocol.SessionCipher(
        this.store,
        remoteAddress
      );
      
      this.sessions.set(remoteAddress.toString(), sessionCipher);
      
      return sessionCipher;
    } catch (error) {
      console.error('åˆå§‹åŒ–ä¼šè¯å¤±è´¥:', error);
      throw error;
    }
  }

  async encryptMessage(recipientAddress, plaintext) {
    let sessionCipher = this.sessions.get(recipientAddress.toString());
    
    if (!sessionCipher) {
      sessionCipher = await this.initializeSession(recipientAddress);
    }
    
    const message = await sessionCipher.encrypt(
      Buffer.from(plaintext, 'utf8')
    );
    
    return {
      type: message.type(),
      body: message.body(),
      serialized: message.serialize()
    };
  }

  async decryptMessage(senderAddress, encryptedMessage) {
    let sessionCipher = this.sessions.get(senderAddress.toString());
    
    if (!sessionCipher) {
      sessionCipher = await this.initializeSession(senderAddress);
    }
    
    let message;
    if (encryptedMessage.type === SignalProtocol.CiphertextMessageType.PreKey) {
      message = SignalProtocol.PreKeySignalMessage.deserialize(
        encryptedMessage.serialized
      );
    } else {
      message = SignalProtocol.SignalMessage.deserialize(
        encryptedMessage.serialized
      );
    }
    
    const plaintext = await sessionCipher.decrypt(message);
    return plaintext.toString('utf8');
  }

  getOwnAddress() {
    return new SignalProtocol.ProtocolAddress(
      this.identityKey.publicKey().serialize().toString('hex').slice(0, 16),
      1
    );
  }
}

// å†…å­˜å­˜å‚¨å®ç°
class InMemorySignalStore {
  constructor() {
    this.identities = new Map();
    this.sessions = new Map();
    this.preKeys = new Map();
    this.signedPreKeys = new Map();
  }

  async saveIdentity(address, identityKey) {
    this.identities.set(address.toString(), identityKey);
    return true;
  }

  async getIdentity(address) {
    return this.identities.get(address.toString()) || null;
  }

  async saveSession(address, record) {
    this.sessions.set(address.toString(), record);
  }

  async getSession(address) {
    return this.sessions.get(address.toString()) || null;
  }

  // å…¶ä»–å¿…éœ€çš„æ–¹æ³•...
}
```

### 4.3 é˜²åƒåœ¾ä¿¡æ¯æœºåˆ¶

```javascript
// services/SpamFilter.js
import crypto from 'crypto';

export class SpamFilter {
  constructor() {
    this.messageHistory = new Map();
    this.rateLimits = new Map();
    this.powDifficulty = 4; // å·¥ä½œé‡è¯æ˜éš¾åº¦
  }

  async isSpam(message, senderId) {
    // 1. æ£€æŸ¥å‘é€é¢‘ç‡
    if (this.checkRateLimit(senderId)) {
      return true;
    }

    // 2. æ£€æŸ¥é‡å¤æ¶ˆæ¯
    if (this.checkDuplicateMessage(message)) {
      return true;
    }

    // 3. éªŒè¯å·¥ä½œé‡è¯æ˜
    if (!this.verifyProofOfWork(message)) {
      return true;
    }

    // 4. å†…å®¹è¿‡æ»¤
    if (this.checkContentSpam(message.content)) {
      return true;
    }

    // æ›´æ–°å†å²è®°å½•
    this.updateMessageHistory(message, senderId);
    
    return false;
  }

  checkRateLimit(senderId) {
    const now = Date.now();
    const limit = this.rateLimits.get(senderId) || { count: 0, window: now };
    
    // æ¯åˆ†é’Ÿæœ€å¤š10æ¡æ¶ˆæ¯
    if (now - limit.window > 60000) {
      limit.count = 0;
      limit.window = now;
    }
    
    limit.count++;
    this.rateLimits.set(senderId, limit);
    
    return limit.count > 10;
  }

  checkDuplicateMessage(message) {
    const hash = crypto.createHash('sha256')
      .update(message.content)
      .digest('hex');
    
    const history = this.messageHistory.get(hash);
    if (history && Date.now() - history.timestamp < 300000) { // 5åˆ†é’Ÿå†…
      return true;
    }
    
    return false;
  }

  verifyProofOfWork(message) {
    if (!message.pow) {
      return false;
    }
    
    const { nonce, difficulty } = message.pow;
    const data = message.content + nonce;
    const hash = crypto.createHash('sha256').update(data).digest('hex');
    
    // æ£€æŸ¥å‰å¯¼é›¶çš„æ•°é‡
    const leadingZeros = hash.match(/^0*/)[0].length;
    return leadingZeros >= difficulty;
  }

  checkContentSpam(content) {
    // ç®€å•çš„å†…å®¹è¿‡æ»¤è§„åˆ™
    const spamPatterns = [
      /é‡å¤å­—ç¬¦{10,}/,
      /å¹¿å‘Š|æ¨å¹¿|åŠ å¾®ä¿¡/i,
      /https?:\/\/[^\s]+/g // é™åˆ¶é“¾æ¥
    ];
    
    return spamPatterns.some(pattern => pattern.test(content));
  }

  updateMessageHistory(message, senderId) {
    const hash = crypto.createHash('sha256')
      .update(message.content)
      .digest('hex');
    
    this.messageHistory.set(hash, {
      timestamp: Date.now(),
      senderId: senderId
    });
  }

  // ç”Ÿæˆå·¥ä½œé‡è¯æ˜
  static generateProofOfWork(content, difficulty = 4) {
    let nonce = 0;
    let hash = '';
    
    do {
      nonce++;
      const data = content + nonce;
      hash = crypto.createHash('sha256').update(data).digest('hex');
    } while (hash.substring(0, difficulty) !== '0'.repeat(difficulty));
    
    return { nonce, difficulty, hash };
  }
}
```

## 5. æ•°æ®å­˜å‚¨æ–¹æ¡ˆ

### 5.1 å†…å­˜å­˜å‚¨ (æ¨è)
```javascript
// services/MemoryStore.js
export class MemoryStore {
  constructor() {
    this.messages = new Map();
    this.sessions = new Map();
    this.peers = new Map();
    this.keys = new Map();
  }

  // æ¶ˆæ¯å­˜å‚¨ (ä¸´æ—¶ï¼Œç”¨äºå»é‡)
  storeMessage(messageId, message, ttl = 300000) { // 5åˆ†é’ŸTTL
    this.messages.set(messageId, {
      ...message,
      timestamp: Date.now(),
      ttl
    });
    
    // å®šæœŸæ¸…ç†è¿‡æœŸæ¶ˆæ¯
    setTimeout(() => {
      this.messages.delete(messageId);
    }, ttl);
  }

  // ä¼šè¯å­˜å‚¨
  storeSession(sessionId, sessionData) {
    this.sessions.set(sessionId, sessionData);
  }

  // èŠ‚ç‚¹ä¿¡æ¯å­˜å‚¨
  storePeer(peerId, peerInfo) {
    this.peers.set(peerId, peerInfo);
  }

  // åŠ å¯†å¯†é’¥å­˜å‚¨
  storeKey(keyId, keyData) {
    this.keys.set(keyId, keyData);
  }

  // æ¸…ç†æ–¹æ³•
  cleanup() {
    const now = Date.now();
    
    // æ¸…ç†è¿‡æœŸæ¶ˆæ¯
    for (const [id, message] of this.messages.entries()) {
      if (now - message.timestamp > message.ttl) {
        this.messages.delete(id);
      }
    }
    
    // æ¸…ç†ç¦»çº¿èŠ‚ç‚¹
    for (const [id, peer] of this.peers.entries()) {
      if (now - peer.lastSeen > 600000) { // 10åˆ†é’Ÿæ— æ´»åŠ¨
        this.peers.delete(id);
      }
    }
  }
}
```

### 5.2 åˆ†å¸ƒå¼å­˜å‚¨ (å¯é€‰)
```javascript
// services/DistributedStore.js
export class DistributedStore {
  constructor(p2pNode) {
    this.node = p2pNode;
    this.dht = p2pNode.services.dht;
    this.replicas = 3; // æ•°æ®å‰¯æœ¬æ•°
  }

  async storeData(key, data) {
    const hash = crypto.createHash('sha256').update(key).digest('hex');
    const peers = await this.findStoragePeers(hash);
    
    const promises = peers.slice(0, this.replicas).map(peer => 
      this.sendStorageRequest(peer, key, data)
    );
    
    await Promise.all(promises);
  }

  async retrieveData(key) {
    const hash = crypto.createHash('sha256').update(key).digest('hex');
    const peers = await this.findStoragePeers(hash);
    
    for (const peer of peers) {
      try {
        const data = await this.sendRetrievalRequest(peer, key);
        if (data) return data;
      } catch (error) {
        continue;
      }
    }
    
    return null;
  }

  async findStoragePeers(hash) {
    const peers = await this.dht.getClosestPeers(hash);
    return peers.slice(0, this.replicas * 2); // è·å–æ›´å¤šå¤‡é€‰èŠ‚ç‚¹
  }

  async sendStorageRequest(peer, key, data) {
    const stream = await this.node.dialProtocol(peer, '/storage/1.0.0');
    const request = {
      type: 'store',
      key,
      data,
      timestamp: Date.now()
    };
    
    await stream.sink([new TextEncoder().encode(JSON.stringify(request))]);
  }

  async sendRetrievalRequest(peer, key) {
    const stream = await this.node.dialProtocol(peer, '/storage/1.0.0');
    const request = {
      type: 'retrieve',
      key,
      timestamp: Date.now()
    };
    
    await stream.sink([new TextEncoder().encode(JSON.stringify(request))]);
    
    const response = await stream.source.next();
    return JSON.parse(new TextDecoder().decode(response.value));
  }
}
```

## 6. éƒ¨ç½²æ–¹æ¡ˆ

### 6.1 æ¡Œé¢åº”ç”¨éƒ¨ç½² (æ¨è)

#### 6.1.1 ä½¿ç”¨Electron
```javascript
// main.js (Electronä¸»è¿›ç¨‹)
const { app, BrowserWindow, ipcMain } = require('electron');
const { P2PNetwork } = require('./src/services/P2PNetwork');

let mainWindow;
let p2pNetwork;

function createWindow() {
  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false,
      preload: path.join(__dirname, 'preload.js')
    }
  });

  mainWindow.loadFile('dist/index.html');
}

app.whenReady().then(async () => {
  createWindow();
  
  // åˆå§‹åŒ–P2Pç½‘ç»œ
  p2pNetwork = new P2PNetwork();
  await p2pNetwork.start();
  
  // è®¾ç½®IPCé€šä¿¡
  setupIPC();
});

function setupIPC() {
  ipcMain.handle('send-message', async (event, message) => {
    return await p2pNetwork.sendMessage(message);
  });
  
  ipcMain.handle('get-peers', async (event) => {
    return Array.from(p2pNetwork.peers.values());
  });
  
  // ç›‘å¬P2Päº‹ä»¶å¹¶è½¬å‘åˆ°æ¸²æŸ“è¿›ç¨‹
  p2pNetwork.on('message', (message) => {
    mainWindow.webContents.send('new-message', message);
  });
  
  p2pNetwork.on('peer:connect', (peer) => {
    mainWindow.webContents.send('peer-connected', peer);
  });
}
```

#### 6.1.2 æ„å»ºé…ç½®
```json
{
  "name": "distributed-chat",
  "version": "1.0.0",
  "main": "main.js",
  "scripts": {
    "build": "vue-tsc --noEmit && vite build",
    "build:electron": "npm run build && electron-builder",
    "dev": "vite",
    "dev:electron": "concurrently \"npm run dev\" \"electron .\"",
    "pack": "electron-builder --dir",
    "dist": "electron-builder"
  },
  "build": {
    "appId": "com.example.distributed-chat",
    "productName": "DistributedChat",
    "directories": {
      "output": "dist-electron"
    },
    "files": [
      "dist/**/*",
      "main.js",
      "preload.js",
      "src/services/**/*"
    ],
    "win": {
      "target": "nsis"
    },
    "mac": {
      "target": "dmg"
    },
    "linux": {
      "target": "AppImage"
    }
  }
}
```

### 6.2 æµè§ˆå™¨åº”ç”¨éƒ¨ç½²

#### 6.2.1 Webç‰ˆæœ¬
```javascript
// main.js (Webç‰ˆæœ¬)
import { createApp } from 'vue';
import { createPinia } from 'pinia';
import App from './App.vue';
import { WebP2PNetwork } from './services/WebP2PNetwork';

const app = createApp(App);
const pinia = createPinia();

app.use(pinia);

// åˆå§‹åŒ–Webç‰ˆP2Pç½‘ç»œ
const p2pNetwork = new WebP2PNetwork();
app.config.globalProperties.$p2p = p2pNetwork;

app.mount('#app');
```

#### 6.2.2 WebRTCé€‚é…
```javascript
// services/WebP2PNetwork.js
export class WebP2PNetwork extends P2PNetwork {
  constructor() {
    super();
    this.isWebEnvironment = true;
  }

  async start() {
    // Webç¯å¢ƒç‰¹æ®Šé…ç½®
    this.node = await createLibp2p({
      addresses: {
        listen: ['/webrtc'] // æµè§ˆå™¨åªæ”¯æŒWebRTC
      },
      transports: [
        webRTC(),
        webSockets({ filter: filters.all }),
        webTransport() // ç°ä»£æµè§ˆå™¨æ”¯æŒ
      ],
      connectionEncryption: [noise()],
      streamMuxers: [yamux()],
      services: {
        identify: identify(),
        pubsub: gossipsub(),
        relay: circuitRelayServer()
      }
    });

    await this.node.start();
    this.setupWebEventHandlers();
    
    console.log('Web P2PèŠ‚ç‚¹å·²å¯åŠ¨');
  }

  setupWebEventHandlers() {
    // å¤„ç†æµè§ˆå™¨ç‰¹æœ‰çš„äº‹ä»¶
    window.addEventListener('beforeunload', () => {
      this.cleanup();
    });
    
    // å¤„ç†ç½‘ç»œçŠ¶æ€å˜åŒ–
    window.addEventListener('online', () => {
      this.handleNetworkOnline();
    });
    
    window.addEventListener('offline', () => {
      this.handleNetworkOffline();
    });
  }

  cleanup() {
    if (this.node) {
      this.node.stop();
    }
  }
}
```

### 6.3 æ··åˆéƒ¨ç½²æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æ··åˆéƒ¨ç½²æ¶æ„                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ¡Œé¢èŠ‚ç‚¹ (Electron)                                    â”‚
â”‚  â”œâ”€ å®Œæ•´P2PåŠŸèƒ½                                         â”‚
â”‚  â”œâ”€ å¯ä½œä¸ºå¼•å¯¼èŠ‚ç‚¹                                      â”‚
â”‚  â”œâ”€ æ”¯æŒæ‰€æœ‰ä¼ è¾“åè®®                                    â”‚
â”‚  â””â”€ ç¦»çº¿å­˜å‚¨èƒ½åŠ›                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  WebèŠ‚ç‚¹ (æµè§ˆå™¨)                                       â”‚
â”‚  â”œâ”€ ä»…WebRTCä¼ è¾“                                        â”‚
â”‚  â”œâ”€ éœ€è¦å¼•å¯¼èŠ‚ç‚¹                                        â”‚
â”‚  â”œâ”€ å†…å­˜å­˜å‚¨                                            â”‚
â”‚  â””â”€ è½»é‡çº§åŠŸèƒ½                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  å¼•å¯¼èŠ‚ç‚¹ (æœåŠ¡å™¨)                                       â”‚
â”‚  â”œâ”€ å¸®åŠ©èŠ‚ç‚¹å‘ç°                                        â”‚
â”‚  â”œâ”€ æ¶ˆæ¯ä¸­ç»§                                            â”‚
â”‚  â”œâ”€ ä¸å­˜å‚¨ç”¨æˆ·æ•°æ®                                      â”‚
â”‚  â””â”€ å¯ç”±ç¤¾åŒºè¿è¥                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## 7. å®‰å…¨è€ƒè™‘

### 7.1 åŒ¿åæ€§ä¿æŠ¤
```javascript
// services/AnonymityService.js
export class AnonymityService {
  constructor() {
    this.onionRouter = new OnionRouter();
    this.mixnet = new MixNet();
  }

  async sendAnonymousMessage(message, recipient) {
    // 1. æ¶ˆæ¯å¡«å…… (é˜²æ­¢æµé‡åˆ†æ)
    const paddedMessage = this.padMessage(message);
    
    // 2. å¤šå±‚åŠ å¯† (æ´‹è‘±è·¯ç”±)
    const encryptedMessage = await this.onionRouter.encrypt(
      paddedMessage, 
      recipient
    );
    
    // 3. éšæœºå»¶è¿Ÿ (é˜²æ­¢æ—¶é—´å…³è”)
    const delay = Math.random() * 5000 + 1000;
    await new Promise(resolve => setTimeout(resolve, delay));
    
    // 4. é€šè¿‡æ··åˆç½‘ç»œå‘é€
    return await this.mixnet.send(encryptedMessage);
  }

  padMessage(message) {
    // å°†æ¶ˆæ¯å¡«å……åˆ°å›ºå®šé•¿åº¦
    const targetLength = 1024;
    const padding = targetLength - message.length;
    
    if (padding > 0) {
      return message + crypto.randomBytes(padding).toString('hex');
    }
    
    return message;
  }
}
```

### 7.2 å‰å‘å®‰å…¨æ€§
```javascript
// services/ForwardSecurityService.js
export class ForwardSecurityService {
  constructor() {
    this.keyRotationInterval = 3600000; // 1å°æ—¶
    this.ephemeralKeys = new Map();
    this.startKeyRotation();
  }

  startKeyRotation() {
    setInterval(() => {
      this.rotateKeys();
    }, this.keyRotationInterval);
  }

  async rotateKeys() {
    // ç”Ÿæˆæ–°çš„ä¸´æ—¶å¯†é’¥
    const newKey = crypto.randomBytes(32);
    
    // æ›´æ–°æ‰€æœ‰ä¼šè¯çš„å¯†é’¥
    for (const [sessionId, session] of this.sessions.entries()) {
      await this.updateSessionKey(sessionId, newKey);
    }
    
    // æ¸…ç†æ—§å¯†é’¥
    this.cleanupOldKeys();
    
    console.log('å¯†é’¥è½®æ¢å®Œæˆ');
  }

  async updateSessionKey(sessionId, newKey) {
    const session = this.sessions.get(sessionId);
    if (session) {
      session.rotateKey(newKey);
    }
  }

  cleanupOldKeys() {
    const now = Date.now();
    const maxAge = this.keyRotationInterval * 2;
    
    for (const [keyId, key] of this.ephemeralKeys.entries()) {
      if (now - key.timestamp > maxAge) {
        this.ephemeralKeys.delete(keyId);
      }
    }
  }
}
```

## 8. æ€§èƒ½ä¼˜åŒ–

### 8.1 æ¶ˆæ¯è·¯ç”±ä¼˜åŒ–
```javascript
// services/RouterOptimizer.js
export class RouterOptimizer {
  constructor() {
    this.routingTable = new Map();
    this.latencyMap = new Map();
    this.connectionQuality = new Map();
  }

  async findOptimalRoute(targetPeer) {
    const routes = await this.discoverRoutes(targetPeer);
    
    // æ ¹æ®å»¶è¿Ÿã€å¸¦å®½ã€ç¨³å®šæ€§è¯„åˆ†
    const scoredRoutes = routes.map(route => ({
      route,
      score: this.calculateRouteScore(route)
    }));
    
    // è¿”å›æœ€ä¼˜è·¯ç”±
    return scoredRoutes.sort((a, b) => b.score - a.score)[0]?.route;
  }

  calculateRouteScore(route) {
    let score = 0;
    
    // è·³æ•°è¶Šå°‘è¶Šå¥½
    score += (10 - route.length) * 10;
    
    // å»¶è¿Ÿè¶Šä½è¶Šå¥½
    const avgLatency = route.reduce((sum, hop) => 
      sum + (this.latencyMap.get(hop) || 1000), 0) / route.length;
    score += Math.max(0, 1000 - avgLatency);
    
    // è¿æ¥è´¨é‡
    const avgQuality = route.reduce((sum, hop) => 
      sum + (this.connectionQuality.get(hop) || 0.5), 0) / route.length;
    score += avgQuality * 100;
    
    return score;
  }

  async discoverRoutes(targetPeer) {
    // ä½¿ç”¨DHTæŸ¥æ‰¾è·¯ç”±
    const peers = await this.dht.getClosestPeers(targetPeer);
    
    // æ„å»ºè·¯ç”±æ ‘
    const routes = [];
    const visited = new Set();
    
    await this.dfsRoutes([], targetPeer, peers, routes, visited, 3);
    
    return routes;
  }

  async dfsRoutes(currentRoute, target, peers, routes, visited, maxDepth) {
    if (maxDepth <= 0) return;
    
    for (const peer of peers) {
      if (visited.has(peer) || currentRoute.includes(peer)) continue;
      
      const newRoute = [...currentRoute, peer];
      
      if (peer === target) {
        routes.push(newRoute);
        continue;
      }
      
      visited.add(peer);
      const nextPeers = await this.getConnectedPeers(peer);
      await this.dfsRoutes(newRoute, target, nextPeers, routes, visited, maxDepth - 1);
      visited.delete(peer);
    }
  }
}
```

### 8.2 è¿æ¥æ± ç®¡ç†
```javascript
// services/ConnectionPoolManager.js
export class ConnectionPoolManager {
  constructor() {
    this.pools = new Map();
    this.maxPoolSize = 10;
    this.connectionTimeout = 30000;
  }

  async getConnection(peerId) {
    let pool = this.pools.get(peerId);
    
    if (!pool) {
      pool = new ConnectionPool(peerId, this.maxPoolSize);
      this.pools.set(peerId, pool);
    }
    
    return await pool.getConnection();
  }

  async releaseConnection(peerId, connection) {
    const pool = this.pools.get(peerId);
    if (pool) {
      pool.releaseConnection(connection);
    }
  }

  cleanup() {
    for (const [peerId, pool] of this.pools.entries()) {
      pool.cleanup();
      if (pool.isEmpty()) {
        this.pools.delete(peerId);
      }
    }
  }
}

class ConnectionPool {
  constructor(peerId, maxSize) {
    this.peerId = peerId;
    this.maxSize = maxSize;
    this.available = [];
    this.busy = [];
    this.pending = [];
  }

  async getConnection() {
    if (this.available.length > 0) {
      const connection = this.available.pop();
      this.busy.push(connection);
      return connection;
    }
    
    if (this.busy.length < this.maxSize) {
      const connection = await this.createConnection();
      this.busy.push(connection);
      return connection;
    }
    
    // ç­‰å¾…å¯ç”¨è¿æ¥
    return new Promise((resolve) => {
      this.pending.push(resolve);
    });
  }

  releaseConnection(connection) {
    const index = this.busy.indexOf(connection);
    if (index > -1) {
      this.busy.splice(index, 1);
      
      if (this.pending.length > 0) {
        const resolve = this.pending.shift();
        this.busy.push(connection);
        resolve(connection);
      } else {
        this.available.push(connection);
      }
    }
  }

  async createConnection() {
    // åˆ›å»ºæ–°è¿æ¥çš„é€»è¾‘
    return await this.node.dial(this.peerId);
  }
}
```

## 9. éƒ¨ç½²æ¸…å•

### 9.1 å¼€å‘ç¯å¢ƒè®¾ç½®
```bash
# 1. å…‹éš†é¡¹ç›®
git clone https://github.com/your-username/distributed-chat.git
cd distributed-chat

# 2. å®‰è£…ä¾èµ–
npm install

# 3. å®‰è£…æ¡Œé¢åº”ç”¨ä¾èµ–
npm install electron electron-builder concurrently

# 4. å¯åŠ¨å¼€å‘æœåŠ¡å™¨
npm run dev

# 5. å¯åŠ¨æ¡Œé¢åº”ç”¨å¼€å‘
npm run dev:electron
```

### 9.2 ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²
```bash
# 1. æ„å»ºWebç‰ˆæœ¬
npm run build

# 2. æ„å»ºæ¡Œé¢åº”ç”¨
npm run build:electron

# 3. åˆ›å»ºå®‰è£…åŒ…
npm run dist

# 4. éƒ¨ç½²å¼•å¯¼èŠ‚ç‚¹ (å¯é€‰)
docker run -d \
  --name chat-bootstrap \
  -p 4001:4001 \
  -p 8080:8080 \
  your-registry/chat-bootstrap:latest
```

### 9.3 Dockeréƒ¨ç½² (å¼•å¯¼èŠ‚ç‚¹)
```dockerfile
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY . .

EXPOSE 4001 8080

CMD ["node", "bootstrap-node.js"]
```

## 10. é¡¹ç›®æ€»ç»“

### 10.1 æŠ€æœ¯ä¼˜åŠ¿
- âœ… **å®Œå…¨å»ä¸­å¿ƒåŒ–**ï¼šæ— å•ç‚¹æ•…éšœ
- âœ… **å†›äº‹çº§åŠ å¯†**ï¼šSignal Protocolä¿è¯é€šä¿¡å®‰å…¨
- âœ… **å®Œå…¨åŒ¿å**ï¼šæ— éœ€èº«ä»½éªŒè¯
- âœ… **æŠ—å®¡æŸ¥**ï¼šæ— æ³•è¢«å°é”æˆ–å…³é—­
- âœ… **è·¨å¹³å°**ï¼šæ”¯æŒæ¡Œé¢å’Œæµè§ˆå™¨
- âœ… **å¯æ‰©å±•**ï¼šæ”¯æŒæ’ä»¶å’Œæ‰©å±•åŠŸèƒ½

### 10.2 æŒ‘æˆ˜ä¸è§£å†³æ–¹æ¡ˆ
- **NATç©¿é€**ï¼šä½¿ç”¨WebRTCå’ŒSTUN/TURNæœåŠ¡å™¨
- **èŠ‚ç‚¹å‘ç°**ï¼šä½¿ç”¨DHTå’Œå¼•å¯¼èŠ‚ç‚¹
- **æ¶ˆæ¯ä¼ æ’­**ï¼šä½¿ç”¨GossipSubåè®®
- **åƒåœ¾ä¿¡æ¯**ï¼šå·¥ä½œé‡è¯æ˜ + å†…å®¹è¿‡æ»¤
- **ç½‘ç»œåˆ†è£‚**ï¼šå¤šè·¯å¾„è·¯ç”±å’Œè‡ªåŠ¨é‡è¿

### 10.3 éƒ¨ç½²å»ºè®®
1. **èµ·æ­¥é˜¶æ®µ**ï¼šå°‘é‡æ¡Œé¢èŠ‚ç‚¹ä½œä¸ºç§å­èŠ‚ç‚¹
2. **å‘å±•é˜¶æ®µ**ï¼šå¢åŠ Webç‰ˆæœ¬ï¼Œé™ä½ä½¿ç”¨é—¨æ§›
3. **æˆç†Ÿé˜¶æ®µ**ï¼šç¤¾åŒºè¿è¥å¼•å¯¼èŠ‚ç‚¹ï¼Œå®Œå…¨å»ä¸­å¿ƒåŒ–

### 10.4 å‘å±•è·¯çº¿å›¾
- **Phase 1**ï¼šåŸºç¡€èŠå¤©åŠŸèƒ½
- **Phase 2**ï¼šæ–‡ä»¶ä¼ è¾“å’Œç¾¤èŠ
- **Phase 3**ï¼šè¯­éŸ³è§†é¢‘é€šè¯
- **Phase 4**ï¼šåº”ç”¨ç”Ÿæ€ç³»ç»Ÿ

è¿™ä¸ªé¡¹ç›®åœ¨æŠ€æœ¯ä¸Šå®Œå…¨å¯è¡Œï¼Œæ ¸å¿ƒæŠ€æœ¯éƒ½å·²æˆç†Ÿã€‚æœ€å¤§çš„æŒ‘æˆ˜æ˜¯ç”¨æˆ·é‡‡ç”¨å’Œç½‘ç»œæ•ˆåº”ã€‚å»ºè®®å…ˆå¼€å‘æ¡Œé¢ç‰ˆæœ¬ï¼Œç„¶åé€æ­¥æ‰©å±•åˆ°Webç‰ˆæœ¬ã€‚ 